{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar spawn = require('cross-spawn');\n\nvar utils = require('./utils');\n\nvar debug = require('debug')('gm');\n\nvar series = require('array-series');\n\nvar PassThrough = require('stream').PassThrough;\n/**\n * Error messaging.\n */\n\n\nvar noBufferConcat = 'gm v1.9.0+ required node v0.8+. Please update your version of node, downgrade gm < 1.9, or do not use `bufferStream`.';\n/**\n * Extend proto\n */\n\nmodule.exports = function (proto) {\n  function args(prop) {\n    return function args() {\n      var len = arguments.length;\n      var a = [];\n      var i = 0;\n\n      for (; i < len; ++i) {\n        a.push(arguments[i]);\n      }\n\n      this[prop] = this[prop].concat(a);\n      return this;\n    };\n  }\n\n  function streamToUnemptyBuffer(stream, callback) {\n    var done = false;\n    var buffers = [];\n    stream.on('data', function (data) {\n      buffers.push(data);\n    });\n    stream.on('end', function () {\n      var result, err;\n      if (done) return;\n      done = true;\n      result = Buffer.concat(buffers);\n      buffers = null;\n\n      if (result.length == 0) {\n        err = new Error(\"Stream yields empty buffer\");\n        callback(err, null);\n      } else {\n        callback(null, result);\n      }\n    });\n    stream.on('error', function (err) {\n      done = true;\n      buffers = null;\n      callback(err);\n    });\n  }\n\n  proto.in = args('_in');\n  proto.out = args('_out');\n  proto._preprocessor = [];\n  proto.preprocessor = args('_preprocessor');\n  /**\n   * Execute the command and write the image to the specified file name.\n   *\n   * @param {String} name\n   * @param {Function} callback\n   * @return {Object} gm\n   */\n\n  proto.write = function write(name, callback) {\n    if (!callback) callback = name, name = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new TypeError(\"gm().write() expects a callback function\");\n    }\n\n    if (!name) {\n      return callback(TypeError(\"gm().write() expects a filename when writing new files\"));\n    }\n\n    this.outname = name;\n    var self = this;\n\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n\n      self._spawn(self.args(), true, callback);\n    });\n  };\n  /**\n   * Execute the command and return stdin and stderr\n   * ReadableStreams providing the image data.\n   * If no callback is passed, a \"through\" stream will be returned,\n   * and stdout will be piped through, otherwise the error will be passed.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback (optional)\n   * @return {Stream}\n   */\n\n\n  proto.stream = function stream(format, callback) {\n    if (!callback && typeof format === 'function') {\n      callback = format;\n      format = null;\n    }\n\n    var throughStream;\n\n    if (\"function\" !== typeof callback) {\n      throughStream = new PassThrough();\n\n      callback = function (err, stdout, stderr) {\n        if (err) throughStream.emit('error', err);else stdout.pipe(throughStream);\n      };\n    }\n\n    if (format) {\n      format = format.split('.').pop();\n      this.outname = format + \":-\";\n    }\n\n    var self = this;\n\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n      return self._spawn(self.args(), false, callback);\n    });\n\n    return throughStream || this;\n  };\n  /**\n   * Convenience function for `proto.stream`.\n   * Simply returns the buffer instead of the stream.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback\n   * @return {null}\n   */\n\n\n  proto.toBuffer = function toBuffer(format, callback) {\n    if (!callback) callback = format, format = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new Error('gm().toBuffer() expects a callback.');\n    }\n\n    return this.stream(format, function (err, stdout) {\n      if (err) return callback(err);\n      streamToUnemptyBuffer(stdout, callback);\n    });\n  };\n  /**\n    * Run any preProcessor functions in series. Used by autoOrient.\n    *\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n\n  proto._preprocess = function _preprocess(callback) {\n    series(this._preprocessor, this, callback);\n  };\n  /**\n    * Execute the command, buffer input and output, return stdout and stderr buffers.\n    *\n    * @param {String} bin\n    * @param {Array} args\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n\n  proto._exec = function _exec(args, callback) {\n    return this._spawn(args, true, callback);\n  };\n  /**\n    * Execute the command with stdin, returning stdout and stderr streams or buffers.\n    * @param {String} bin\n    * @param {Array} args\n    * @param {ReadableStream} stream\n    * @param {Boolean} shouldBuffer\n    * @param {Function} callback, signature (err, stdout, stderr) -> * \n    * @return {Object} gm\n    * @TODO refactor this mess\n    */\n\n\n  proto._spawn = function _spawn(args, bufferOutput, callback) {\n    var appPath = this._options.appPath || '';\n    var bin = this._options.imageMagick ? appPath + args.shift() : appPath + 'gm';\n    var cmd = bin + ' ' + args.map(utils.escape).join(' '),\n        self = this,\n        proc,\n        err,\n        timeout = parseInt(this._options.timeout),\n        disposers = this._options.disposers,\n        timeoutId;\n    debug(cmd); //imageMagick does not support minify (https://github.com/aheckmann/gm/issues/385)\n\n    if (args.indexOf(\"-minify\") > -1 && this._options.imageMagick) {\n      err = new Error(\"imageMagick does not support minify, use -scale or -sample. Alternatively, use graphicsMagick\");\n      return cb(err);\n    }\n\n    try {\n      proc = spawn(bin, args);\n    } catch (e) {\n      return cb(e);\n    }\n\n    proc.stdin.once('error', cb);\n    proc.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        cb(new Error('Could not execute GraphicsMagick/ImageMagick: ' + cmd + \" this most likely means the gm/convert binaries can't be found\"));\n      } else {\n        cb(err);\n      }\n    });\n\n    if (timeout) {\n      timeoutId = setTimeout(function () {\n        dispose('gm() resulted in a timeout.');\n      }, timeout);\n    }\n\n    if (disposers) {\n      disposers.forEach(function (disposer) {\n        disposer.events.forEach(function (event) {\n          disposer.emitter.on(event, dispose);\n        });\n      });\n    }\n\n    if (self.sourceBuffer) {\n      proc.stdin.write(this.sourceBuffer);\n      proc.stdin.end();\n    } else if (self.sourceStream) {\n      if (!self.sourceStream.readable) {\n        err = new Error(\"gm().stream() or gm().write() with a non-readable stream.\");\n        return cb(err);\n      }\n\n      self.sourceStream.pipe(proc.stdin); // bufferStream\n      // We convert the input source from a stream to a buffer.\n\n      if (self.bufferStream && !this._buffering) {\n        if (!Buffer.concat) {\n          throw new Error(noBufferConcat);\n        } // Incase there are multiple processes in parallel,\n        // we only need one\n\n\n        self._buffering = true;\n        streamToUnemptyBuffer(self.sourceStream, function (err, buffer) {\n          self.sourceBuffer = buffer;\n          self.sourceStream = null; // The stream is now dead\n        });\n      }\n    } // for _exec operations (identify() mostly), we also\n    // need to buffer the output stream before returning\n\n\n    if (bufferOutput) {\n      var stdout = '',\n          stderr = '',\n          onOut,\n          onErr,\n          onExit;\n      proc.stdout.on('data', onOut = function (data) {\n        stdout += data;\n      });\n      proc.stderr.on('data', onErr = function (data) {\n        stderr += data;\n      });\n      proc.on('close', onExit = function (code, signal) {\n        if (code !== 0 || signal !== null) {\n          err = new Error('Command failed: ' + stderr);\n          err.code = code;\n          err.signal = signal;\n        }\n\n        ;\n        cb(err, stdout, stderr, cmd);\n        stdout = stderr = onOut = onErr = onExit = null;\n      });\n    } else {\n      cb(null, proc.stdout, proc.stderr, cmd);\n    }\n\n    return self;\n\n    function cb(err, stdout, stderr, cmd) {\n      if (cb.called) return;\n      if (timeoutId) clearTimeout(timeoutId);\n      cb.called = 1;\n\n      if (args[0] !== 'identify' && bin !== 'identify') {\n        self._in = [];\n        self._out = [];\n      }\n\n      callback.call(self, err, stdout, stderr, cmd);\n    }\n\n    function dispose(msg) {\n      var message = msg ? msg : 'gm() was disposed';\n      err = new Error(message);\n      cb(err);\n\n      if (proc.exitCode === null) {\n        proc.stdin.pause();\n        proc.kill();\n      }\n    }\n  };\n  /**\n   * Returns arguments to be used in the command.\n   *\n   * @return {Array}\n   */\n\n\n  proto.args = function args() {\n    var outname = this.outname || \"-\";\n    if (this._outputFormat) outname = this._outputFormat + ':' + outname;\n    return [].concat(this._subCommand, this._in, this.src(), this._out, outname).filter(Boolean); // remove falsey\n  };\n  /**\n   * Adds an img source formatter.\n   *\n   * `formatters` are passed an array of images which will be\n   * used as 'input' images for the command. Useful for methods\n   * like `.append()` where multiple source images may be used.\n   *\n   * @param {Function} formatter\n   * @return {gm} this\n   */\n\n\n  proto.addSrcFormatter = function addSrcFormatter(formatter) {\n    if ('function' != typeof formatter) throw new TypeError('sourceFormatter must be a function');\n    this._sourceFormatters || (this._sourceFormatters = []);\n\n    this._sourceFormatters.push(formatter);\n\n    return this;\n  };\n  /**\n   * Applies all _sourceFormatters\n   *\n   * @return {Array}\n   */\n\n\n  proto.src = function src() {\n    var arr = [];\n\n    for (var i = 0; i < this._sourceFormatters.length; ++i) {\n      this._sourceFormatters[i].call(this, arr);\n    }\n\n    return arr;\n  };\n  /**\n   * Image types.\n   */\n\n\n  var types = {\n    'jpg': /\\.jpe?g$/i,\n    'png': /\\.png$/i,\n    'gif': /\\.gif$/i,\n    'tiff': /\\.tif?f$/i,\n    'bmp': /(?:\\.bmp|\\.dib)$/i,\n    'webp': /\\.webp$/i\n  };\n  types.jpeg = types.jpg;\n  types.tif = types.tiff;\n  types.dib = types.bmp;\n  /**\n   * Determine the type of source image.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   * @example\n   *   if (this.inputIs('png')) ...\n   */\n\n  proto.inputIs = function inputIs(type) {\n    if (!type) return false;\n    var rgx = types[type];\n\n    if (!rgx) {\n      if ('.' !== type[0]) type = '.' + type;\n      rgx = new RegExp('\\\\' + type + '$', 'i');\n    }\n\n    return rgx.test(this.source);\n  };\n  /**\n   * add disposer (like 'close' of http.IncomingMessage) in order to dispose gm() with any event\n   *\n   * @param {EventEmitter} emitter\n   * @param {Array} events\n   * @return {Object} gm\n   * @example\n   *   command.addDisposer(req, ['close', 'end', 'finish']);\n   */\n\n\n  proto.addDisposer = function addDisposer(emitter, events) {\n    if (!this._options.disposers) {\n      this._options.disposers = [];\n    }\n\n    this._options.disposers.push({\n      emitter: emitter,\n      events: events\n    });\n\n    return this;\n  };\n};","map":{"version":3,"sources":["/home/a/Documents/GitHub/react-ts-project/node_modules/gm/lib/command.js"],"names":["spawn","require","utils","debug","series","PassThrough","noBufferConcat","module","exports","proto","args","prop","len","arguments","length","a","i","push","concat","streamToUnemptyBuffer","stream","callback","done","buffers","on","data","result","err","Buffer","Error","in","out","_preprocessor","preprocessor","write","name","TypeError","outname","self","_preprocess","_spawn","format","throughStream","stdout","stderr","emit","pipe","split","pop","toBuffer","_exec","bufferOutput","appPath","_options","bin","imageMagick","shift","cmd","map","escape","join","proc","timeout","parseInt","disposers","timeoutId","indexOf","cb","e","stdin","once","code","setTimeout","dispose","forEach","disposer","events","event","emitter","sourceBuffer","end","sourceStream","readable","bufferStream","_buffering","buffer","onOut","onErr","onExit","signal","called","clearTimeout","_in","_out","call","msg","message","exitCode","pause","kill","_outputFormat","_subCommand","src","filter","Boolean","addSrcFormatter","formatter","_sourceFormatters","arr","types","jpeg","jpg","tif","tiff","dib","bmp","inputIs","type","rgx","RegExp","test","source","addDisposer"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar spawn = require('cross-spawn');\nvar utils = require('./utils');\nvar debug = require('debug')('gm');\nvar series = require('array-series');\nvar PassThrough = require('stream').PassThrough;\n\n/**\n * Error messaging.\n */\n\nvar noBufferConcat = 'gm v1.9.0+ required node v0.8+. Please update your version of node, downgrade gm < 1.9, or do not use `bufferStream`.';\n\n/**\n * Extend proto\n */\n\nmodule.exports = function (proto) {\n\n  function args (prop) {\n    return function args () {\n      var len = arguments.length;\n      var a = [];\n      var i = 0;\n\n      for (; i < len; ++i) {\n        a.push(arguments[i]);\n      }\n\n      this[prop] = this[prop].concat(a);\n      return this;\n    }\n  }\n  \n  function streamToUnemptyBuffer(stream, callback) {\n    var done = false\n    var buffers = []\n\n    stream.on('data', function (data) {\n      buffers.push(data)\n    })\n\n    stream.on('end', function () {\n      var result, err;\n      if (done)\n        return\n\n      done = true\n      result = Buffer.concat(buffers)\n      buffers = null\n      if (result.length==0)\n      {\n          err = new Error(\"Stream yields empty buffer\"); \n          callback(err, null);\n      } else {\n          callback(null, result);\n      }\n    })\n\n    stream.on('error', function (err) {\n      done = true\n      buffers = null\n      callback(err)\n    })\n  }\n\n  proto.in = args('_in');\n  proto.out = args('_out');\n\n  proto._preprocessor = [];\n  proto.preprocessor = args('_preprocessor');\n\n  /**\n   * Execute the command and write the image to the specified file name.\n   *\n   * @param {String} name\n   * @param {Function} callback\n   * @return {Object} gm\n   */\n\n  proto.write = function write (name, callback) {\n    if (!callback) callback = name, name = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new TypeError(\"gm().write() expects a callback function\")\n    }\n\n    if (!name) {\n      return callback(TypeError(\"gm().write() expects a filename when writing new files\"));\n    }\n\n    this.outname = name;\n\n    var self = this;\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n      self._spawn(self.args(), true, callback);\n    });\n  }\n\n  /**\n   * Execute the command and return stdin and stderr\n   * ReadableStreams providing the image data.\n   * If no callback is passed, a \"through\" stream will be returned,\n   * and stdout will be piped through, otherwise the error will be passed.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback (optional)\n   * @return {Stream}\n   */\n\n  proto.stream = function stream (format, callback) {\n    if (!callback && typeof format === 'function') {\n      callback = format;\n      format = null;\n    }\n\n    var throughStream;\n\n    if (\"function\" !== typeof callback) {\n      throughStream = new PassThrough();\n      callback = function (err, stdout, stderr) {\n        if (err) throughStream.emit('error', err);\n        else stdout.pipe(throughStream);\n      }\n    }\n\n    if (format) {\n      format = format.split('.').pop();\n      this.outname = format + \":-\";\n    }\n\n    var self = this;\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n      return self._spawn(self.args(), false, callback);\n    });\n\n    return throughStream || this;\n  }\n\n  /**\n   * Convenience function for `proto.stream`.\n   * Simply returns the buffer instead of the stream.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback\n   * @return {null}\n   */\n\n  proto.toBuffer = function toBuffer (format, callback) {\n    if (!callback) callback = format, format = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new Error('gm().toBuffer() expects a callback.');\n    }\n\n    return this.stream(format, function (err, stdout) {\n      if (err) return callback(err);\n\n      streamToUnemptyBuffer(stdout, callback);\n    })\n  }\n\n  /**\n    * Run any preProcessor functions in series. Used by autoOrient.\n    *\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n  proto._preprocess = function _preprocess (callback) {\n    series(this._preprocessor, this, callback);\n  }\n\n  /**\n    * Execute the command, buffer input and output, return stdout and stderr buffers.\n    *\n    * @param {String} bin\n    * @param {Array} args\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n  proto._exec = function _exec (args, callback) {\n    return this._spawn(args, true, callback);\n  }\n\n  /**\n    * Execute the command with stdin, returning stdout and stderr streams or buffers.\n    * @param {String} bin\n    * @param {Array} args\n    * @param {ReadableStream} stream\n    * @param {Boolean} shouldBuffer\n    * @param {Function} callback, signature (err, stdout, stderr) -> * \n    * @return {Object} gm\n    * @TODO refactor this mess\n    */\n\n  proto._spawn = function _spawn (args, bufferOutput, callback) {\n    var appPath = this._options.appPath || '';\n    var bin = this._options.imageMagick\n      ? appPath + args.shift()\n      : appPath + 'gm'\n\n    var cmd = bin + ' ' + args.map(utils.escape).join(' ')\n      , self = this\n      , proc, err\n      , timeout = parseInt(this._options.timeout)\n      , disposers = this._options.disposers\n      , timeoutId;\n\n    debug(cmd);\n    //imageMagick does not support minify (https://github.com/aheckmann/gm/issues/385)\n    if(args.indexOf(\"-minify\") > -1 && this._options.imageMagick){\n      err = new Error(\"imageMagick does not support minify, use -scale or -sample. Alternatively, use graphicsMagick\");\n      return cb(err);\n    }\n    try {\n      proc = spawn(bin, args);\n    } catch (e) {\n      return cb(e);\n    }\n    proc.stdin.once('error', cb);\n    \n    proc.on('error', function(err){\n      if (err.code === 'ENOENT') {\n        cb(new Error('Could not execute GraphicsMagick/ImageMagick: '+cmd+\" this most likely means the gm/convert binaries can't be found\"));\n      } else {\n        cb(err);\n      }\n    });\n\n    if (timeout) {\n      timeoutId = setTimeout(function(){\n        dispose('gm() resulted in a timeout.');\n      }, timeout);\n    }\n\n    if (disposers) {\n      disposers.forEach(function(disposer) {\n        disposer.events.forEach(function(event) {\n          disposer.emitter.on(event, dispose);\n        });\n      });\n    }\n\n    if (self.sourceBuffer) {\n      proc.stdin.write(this.sourceBuffer);\n      proc.stdin.end();\n    } else if (self.sourceStream) {\n\n      if (!self.sourceStream.readable) {\n        err = new Error(\"gm().stream() or gm().write() with a non-readable stream.\");\n        return cb(err);\n      }\n\n      self.sourceStream.pipe(proc.stdin);\n\n      // bufferStream\n      // We convert the input source from a stream to a buffer.\n      if (self.bufferStream && !this._buffering) {\n        if (!Buffer.concat) {\n          throw new Error(noBufferConcat);\n        }\n\n        // Incase there are multiple processes in parallel,\n        // we only need one\n        self._buffering = true;\n\n        streamToUnemptyBuffer(self.sourceStream, function (err, buffer) {\n          self.sourceBuffer = buffer;\n          self.sourceStream = null; // The stream is now dead\n        })\n      }\n    }\n\n    // for _exec operations (identify() mostly), we also\n    // need to buffer the output stream before returning\n    if (bufferOutput) {\n      var stdout = ''\n        , stderr = ''\n        , onOut\n        , onErr\n        , onExit\n\n      proc.stdout.on('data', onOut = function (data) {\n        stdout += data;\n      });\n\n      proc.stderr.on('data', onErr = function (data) {\n        stderr += data;\n      });\n\n      proc.on('close', onExit = function (code, signal) {\n        if (code !== 0 || signal !== null) {\n          err = new Error('Command failed: ' + stderr);\n          err.code = code;\n          err.signal = signal;\n        };\n        cb(err, stdout, stderr, cmd);\n        stdout = stderr = onOut = onErr = onExit = null;\n      });\n    } else {\n      cb(null, proc.stdout, proc.stderr, cmd);\n    }\n\n    return self;\n\n    function cb (err, stdout, stderr, cmd) {\n      if (cb.called) return;\n      if (timeoutId) clearTimeout(timeoutId);\n      cb.called = 1;\n      if (args[0] !== 'identify' && bin !== 'identify') {\n\tself._in = [];\n\tself._out = [];\n      }\n      callback.call(self, err, stdout, stderr, cmd);\n    }\n\n    function dispose (msg) {\n      var message = msg ? msg : 'gm() was disposed';\n      err = new Error(message);\n      cb(err);\n      if (proc.exitCode === null) {\n        proc.stdin.pause();\n        proc.kill();\n      }\n    }\n  }\n\n  /**\n   * Returns arguments to be used in the command.\n   *\n   * @return {Array}\n   */\n\n  proto.args = function args () {\n    var outname = this.outname || \"-\";\n  \tif (this._outputFormat) outname = this._outputFormat + ':' + outname;\n\n    return [].concat(\n        this._subCommand\n      , this._in\n      , this.src()\n      , this._out\n      , outname\n    ).filter(Boolean); // remove falsey\n  }\n\n  /**\n   * Adds an img source formatter.\n   *\n   * `formatters` are passed an array of images which will be\n   * used as 'input' images for the command. Useful for methods\n   * like `.append()` where multiple source images may be used.\n   *\n   * @param {Function} formatter\n   * @return {gm} this\n   */\n\n  proto.addSrcFormatter = function addSrcFormatter (formatter) {\n    if ('function' != typeof formatter)\n      throw new TypeError('sourceFormatter must be a function');\n    this._sourceFormatters || (this._sourceFormatters = []);\n    this._sourceFormatters.push(formatter);\n    return this;\n  }\n\n  /**\n   * Applies all _sourceFormatters\n   *\n   * @return {Array}\n   */\n\n  proto.src = function src () {\n    var arr = [];\n    for (var i = 0; i < this._sourceFormatters.length; ++i) {\n      this._sourceFormatters[i].call(this, arr);\n    }\n    return arr;\n  }\n\n  /**\n   * Image types.\n   */\n\n  var types = {\n      'jpg': /\\.jpe?g$/i\n    , 'png' : /\\.png$/i\n    , 'gif' : /\\.gif$/i\n    , 'tiff': /\\.tif?f$/i\n    , 'bmp' : /(?:\\.bmp|\\.dib)$/i\n    , 'webp': /\\.webp$/i\n  };\n\n  types.jpeg = types.jpg;\n  types.tif = types.tiff;\n  types.dib = types.bmp;\n\n  /**\n   * Determine the type of source image.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   * @example\n   *   if (this.inputIs('png')) ...\n   */\n\n  proto.inputIs = function inputIs (type) {\n    if (!type) return false;\n\n    var rgx = types[type];\n    if (!rgx) {\n      if ('.' !== type[0]) type = '.' + type;\n      rgx = new RegExp('\\\\' + type + '$', 'i');\n    }\n\n    return rgx.test(this.source);\n  }\n\n  /**\n   * add disposer (like 'close' of http.IncomingMessage) in order to dispose gm() with any event\n   *\n   * @param {EventEmitter} emitter\n   * @param {Array} events\n   * @return {Object} gm\n   * @example\n   *   command.addDisposer(req, ['close', 'end', 'finish']);\n   */\n\n  proto.addDisposer = function addDisposer (emitter, events) {\n    if (!this._options.disposers) {\n      this._options.disposers = [];\n    }\n    this._options.disposers.push({\n      emitter: emitter,\n      events: events\n    });\n    return this;\n  };\n}\n"]},"metadata":{},"sourceType":"script"}