{"ast":null,"code":"/**\n * Extend proto.\n */\nmodule.exports = function (gm) {\n  var proto = gm.prototype;\n  /**\n   * `identify` states\n   */\n\n  const IDENTIFYING = 1;\n  const IDENTIFIED = 2;\n  /**\n   * Map getter functions to output names.\n   *\n   * - format: specifying the -format argument (see man gm)\n   * - verbose: use -verbose instead of -format (only if necessary b/c its slow)\n   * - helper: use the conversion helper\n   */\n\n  var map = {\n    'format': {\n      key: 'format',\n      format: '%m ',\n      helper: 'Format'\n    },\n    'depth': {\n      key: 'depth',\n      format: '%q'\n    },\n    'filesize': {\n      key: 'Filesize',\n      format: '%b'\n    },\n    'size': {\n      key: 'size',\n      format: '%wx%h ',\n      helper: 'Geometry'\n    },\n    'color': {\n      key: 'color',\n      format: '%k',\n      helper: 'Colors'\n    },\n    'orientation': {\n      key: 'Orientation',\n      format: '%[EXIF:Orientation]',\n      helper: 'Orientation'\n    },\n    'res': {\n      key: 'Resolution',\n      verbose: true\n    }\n  };\n  /**\n   * Getter functions\n   */\n\n  Object.keys(map).forEach(function (getter) {\n    proto[getter] = function (opts, callback) {\n      if (!callback) callback = opts, opts = {};\n      if (!callback) return this;\n      var val = map[getter],\n          key = val.key,\n          self = this;\n\n      if (self.data[key]) {\n        callback.call(self, null, self.data[key]);\n        return self;\n      }\n\n      self.on(getter, callback);\n      self.bufferStream = !!opts.bufferStream;\n\n      if (val.verbose) {\n        self.identify(opts, function (err, stdout, stderr, cmd) {\n          if (err) {\n            self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          } else {\n            self.emit(getter, err, self.data[key]);\n          }\n        });\n        return self;\n      }\n\n      var args = makeArgs(self, val);\n\n      self._exec(args, function (err, stdout, stderr, cmd) {\n        if (err) {\n          self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          return;\n        }\n\n        var result = (stdout || '').trim();\n\n        if (val.helper in helper) {\n          helper[val.helper](self.data, result);\n        } else {\n          self.data[key] = result;\n        }\n\n        self.emit(getter, err, self.data[key]);\n      });\n\n      return self;\n    };\n  });\n  /**\n   * identify command\n   *\n   * Overwrites all internal data with the parsed output\n   * which is more accurate than the fast shortcut\n   * getters.\n   */\n\n  proto.identify = function identify(opts, callback) {\n    // identify with pattern\n    if (typeof opts === 'string') {\n      opts = {\n        format: opts\n      };\n    }\n\n    if (!callback) callback = opts, opts = {};\n    if (!callback) return this;\n    if (opts && opts.format) return identifyPattern.call(this, opts, callback);\n    var self = this;\n\n    if (IDENTIFIED === self._identifyState) {\n      callback.call(self, null, self.data);\n      return self;\n    }\n\n    self.on('identify', callback);\n\n    if (IDENTIFYING === self._identifyState) {\n      return self;\n    }\n\n    self._identifyState = IDENTIFYING;\n    self.bufferStream = !!opts.bufferStream;\n    var args = makeArgs(self, {\n      verbose: true\n    });\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      err = parse(stdout, self);\n\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      self.data.path = self.source;\n      self.emit('identify', null, self.data);\n      self._identifyState = IDENTIFIED;\n    });\n\n    return self;\n  };\n  /**\n   * identify with pattern\n   *\n   * Execute `identify -format` with custom pattern\n   */\n\n\n  function identifyPattern(opts, callback) {\n    var self = this;\n    self.bufferStream = !!opts.bufferStream;\n    var args = makeArgs(self, opts);\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        return callback.call(self, err, undefined, stdout, stderr, cmd);\n      }\n\n      callback.call(self, err, (stdout || '').trim());\n    });\n\n    return self;\n  }\n  /**\n   * Parses `identify` responses.\n   *\n   * @param {String} stdout\n   * @param {Gm} self\n   * @return {Error} [optionally]\n   */\n\n\n  function parse(stdout, self) {\n    // normalize\n    var parts = (stdout || \"\").trim().replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\"); // skip the first line (its just the filename)\n\n    parts.shift();\n\n    try {\n      var len = parts.length,\n          rgx1 = /^( *)(.+?): (.*)$/ // key: val\n      ,\n          rgx2 = /^( *)(.+?):$/ // key: begin nested object\n      ,\n          out = {\n        indent: {}\n      },\n          level = null,\n          lastkey,\n          i = 0,\n          res,\n          o;\n\n      for (; i < len; ++i) {\n        res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);\n        if (!res) continue;\n        var indent = res[1].length,\n            key = res[2] ? res[2].trim() : '';\n        if ('Image' == key || 'Warning' == key) continue;\n        var val = res[3] ? res[3].trim() : null; // first iteration?\n\n        if (null === level) {\n          level = indent;\n          o = out.root = out.indent[level] = self.data;\n        } else if (indent < level) {\n          // outdent\n          if (!(indent in out.indent)) {\n            continue;\n          }\n\n          o = out.indent[indent];\n        } else if (indent > level) {\n          // dropping into a nested object\n          out.indent[level] = o; // weird format, key/val pair with nested children. discard the val\n\n          o = o[lastkey] = {};\n        }\n\n        level = indent;\n\n        if (val) {\n          // if previous key was exist and we got the same key\n          // cast it to an array.\n          if (o.hasOwnProperty(key)) {\n            // cast it to an array and dont forget the previous value\n            if (!Array.isArray(o[key])) {\n              var tmp = o[key];\n              o[key] = [tmp];\n            } // set value\n\n\n            o[key].push(val);\n          } else {\n            o[key] = val;\n          }\n\n          if (key in helper) {\n            helper[key](o, val);\n          }\n        }\n\n        lastkey = key;\n      }\n    } catch (err) {\n      err.message = err.message + \"\\n\\n  Identify stdout:\\n  \" + stdout;\n      return err;\n    }\n  }\n  /**\n   * Create an argument array for the identify command.\n   *\n   * @param {gm} self\n   * @param {Object} val\n   * @return {Array}\n   */\n\n\n  function makeArgs(self, val) {\n    var args = ['identify', '-ping'];\n\n    if (val.format) {\n      args.push('-format', val.format);\n    }\n\n    if (val.verbose) {\n      args.push('-verbose');\n    }\n\n    args = args.concat(self.src());\n    return args;\n  }\n  /**\n   * Map exif orientation codes to orientation names.\n   */\n\n\n  var orientations = {\n    '1': 'TopLeft',\n    '2': 'TopRight',\n    '3': 'BottomRight',\n    '4': 'BottomLeft',\n    '5': 'LeftTop',\n    '6': 'RightTop',\n    '7': 'RightBottom',\n    '8': 'LeftBottom'\n  };\n  /**\n   * identify -verbose helpers\n   */\n\n  var helper = gm.identifyHelpers = {};\n\n  helper.Geometry = function Geometry(o, val) {\n    // We only want the size of the first frame.\n    // Each frame is separated by a space.\n    var split = val.split(\" \").shift().split(\"x\");\n    var width = parseInt(split[0], 10);\n    var height = parseInt(split[1], 10);\n\n    if (o.size && o.size.width && o.size.height) {\n      if (width > o.size.width) o.size.width = width;\n      if (height > o.size.height) o.size.height = height;\n    } else {\n      o.size = {\n        width: width,\n        height: height\n      };\n    }\n  };\n\n  helper.Format = function Format(o, val) {\n    o.format = val.split(\" \")[0];\n  };\n\n  helper.Depth = function Depth(o, val) {\n    o.depth = parseInt(val, 10);\n  };\n\n  helper.Colors = function Colors(o, val) {\n    o.color = parseInt(val, 10);\n  };\n\n  helper.Orientation = function Orientation(o, val) {\n    if (val in orientations) {\n      o['Profile-EXIF'] || (o['Profile-EXIF'] = {});\n      o['Profile-EXIF'].Orientation = val;\n      o.Orientation = orientations[val];\n    } else {\n      o.Orientation = val || 'Unknown';\n    }\n  };\n};","map":{"version":3,"sources":["/home/a/Documents/GitHub/react-ts-project/node_modules/gm/lib/getters.js"],"names":["module","exports","gm","proto","prototype","IDENTIFYING","IDENTIFIED","map","key","format","helper","verbose","Object","keys","forEach","getter","opts","callback","val","self","data","call","on","bufferStream","identify","err","stdout","stderr","cmd","emit","args","makeArgs","_exec","result","trim","identifyPattern","_identifyState","parse","path","source","undefined","parts","replace","split","shift","len","length","rgx1","rgx2","out","indent","level","lastkey","i","res","o","exec","root","hasOwnProperty","Array","isArray","tmp","push","message","concat","src","orientations","identifyHelpers","Geometry","width","parseInt","height","size","Format","Depth","depth","Colors","color","Orientation"],"mappings":"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","sourcesContent":["/**\n * Extend proto.\n */\n\nmodule.exports = function (gm) {\n\n  var proto = gm.prototype;\n\n  /**\n   * `identify` states\n   */\n\n  const IDENTIFYING = 1;\n  const IDENTIFIED = 2;\n\n  /**\n   * Map getter functions to output names.\n   *\n   * - format: specifying the -format argument (see man gm)\n   * - verbose: use -verbose instead of -format (only if necessary b/c its slow)\n   * - helper: use the conversion helper\n   */\n\n  var map = {\n      'format': { key: 'format', format: '%m ', helper: 'Format' }\n    , 'depth':  { key: 'depth',  format: '%q' }\n    , 'filesize': { key: 'Filesize', format: '%b' }\n    , 'size':  { key: 'size', format: '%wx%h ', helper: 'Geometry' }\n    , 'color': { key: 'color', format: '%k',  helper: 'Colors' }\n    , 'orientation': { key: 'Orientation', format: '%[EXIF:Orientation]', helper: 'Orientation' }\n    , 'res':   { key: 'Resolution', verbose: true }\n  }\n\n  /**\n   * Getter functions\n   */\n\n  Object.keys(map).forEach(function (getter) {\n    proto[getter] = function (opts, callback) {\n      if (!callback) callback = opts, opts = {};\n      if (!callback) return this;\n\n      var val = map[getter]\n        , key = val.key\n        , self = this;\n\n      if (self.data[key]) {\n        callback.call(self, null, self.data[key]);\n        return self;\n      }\n\n      self.on(getter, callback);\n\n      self.bufferStream = !!opts.bufferStream;\n\n      if (val.verbose) {\n        self.identify(opts, function (err, stdout, stderr, cmd) {\n          if (err) {\n            self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          } else {\n            self.emit(getter, err, self.data[key]);\n          }\n        });\n        return self;\n      }\n\n      var args = makeArgs(self, val);\n      self._exec(args, function (err, stdout, stderr, cmd) {\n        if (err) {\n          self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          return;\n        }\n\n        var result = (stdout||'').trim();\n\n        if (val.helper in helper) {\n          helper[val.helper](self.data, result);\n        } else {\n          self.data[key] = result;\n        }\n\n        self.emit(getter, err, self.data[key]);\n      });\n\n      return self;\n    }\n  });\n\n  /**\n   * identify command\n   *\n   * Overwrites all internal data with the parsed output\n   * which is more accurate than the fast shortcut\n   * getters.\n   */\n\n  proto.identify = function identify (opts, callback) {\n    // identify with pattern\n    if (typeof(opts) === 'string') {\n      opts = {\n        format: opts\n      }\n    }\n    if (!callback) callback = opts, opts = {};\n    if (!callback) return this;\n    if (opts && opts.format) return identifyPattern.call(this, opts, callback);\n\n    var self = this;\n\n    if (IDENTIFIED === self._identifyState) {\n      callback.call(self, null, self.data);\n      return self;\n    }\n\n    self.on('identify', callback);\n\n    if (IDENTIFYING === self._identifyState) {\n      return self;\n    }\n\n    self._identifyState = IDENTIFYING;\n\n    self.bufferStream = !!opts.bufferStream;\n\n    var args = makeArgs(self, { verbose: true });\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      err = parse(stdout, self);\n\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      self.data.path = self.source;\n\n      self.emit('identify', null, self.data);\n      self._identifyState = IDENTIFIED;\n    });\n\n    return self;\n  }\n\n\n  /**\n   * identify with pattern\n   *\n   * Execute `identify -format` with custom pattern\n   */\n\n  function identifyPattern (opts, callback) {\n    var self = this;\n\n    self.bufferStream = !!opts.bufferStream;\n\n    var args = makeArgs(self, opts);\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        return callback.call(self, err, undefined, stdout, stderr, cmd);\n      }\n\n      callback.call(self, err, (stdout||'').trim());\n    });\n\n    return self;\n  }\n\n\n  /**\n   * Parses `identify` responses.\n   *\n   * @param {String} stdout\n   * @param {Gm} self\n   * @return {Error} [optionally]\n   */\n\n  function parse (stdout, self) {\n    // normalize\n    var parts = (stdout||\"\").trim().replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n\n    // skip the first line (its just the filename)\n    parts.shift();\n\n    try {\n      var len = parts.length\n        , rgx1 = /^( *)(.+?): (.*)$/ // key: val\n        , rgx2 = /^( *)(.+?):$/      // key: begin nested object\n        , out = { indent: {} }\n        , level = null\n        , lastkey\n        , i = 0\n        , res\n        , o\n\n      for (; i < len; ++i) {\n        res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);\n        if (!res) continue;\n\n        var indent = res[1].length\n          , key = res[2] ? res[2].trim() : '';\n\n        if ('Image' == key || 'Warning' == key) continue;\n\n        var val = res[3] ? res[3].trim() : null;\n\n        // first iteration?\n        if (null === level) {\n          level = indent;\n          o = out.root = out.indent[level] = self.data;\n        } else if (indent < level) {\n          // outdent\n          if (!(indent in out.indent)) {\n            continue;\n          }\n          o = out.indent[indent];\n        } else if (indent > level) {\n          // dropping into a nested object\n          out.indent[level] = o;\n          // weird format, key/val pair with nested children. discard the val\n          o = o[lastkey] = {};\n        }\n\n        level = indent;\n\n        if (val) {\n          // if previous key was exist and we got the same key\n          // cast it to an array.\n          if(o.hasOwnProperty(key)){\n            // cast it to an array and dont forget the previous value\n            if(!Array.isArray(o[key])){\n              var tmp = o[key];\n              o[key] = [tmp];\n            }\n\n            // set value\n            o[key].push(val);\n          } else {\n            o[key] = val;\n          }\n\n          if (key in helper) {\n            helper[key](o, val);\n          }\n        }\n\n        lastkey = key;\n      }\n\n    } catch (err) {\n      err.message = err.message + \"\\n\\n  Identify stdout:\\n  \" + stdout;\n      return err;\n    }\n  }\n\n  /**\n   * Create an argument array for the identify command.\n   *\n   * @param {gm} self\n   * @param {Object} val\n   * @return {Array}\n   */\n\n  function makeArgs (self, val) {\n    var args = [\n        'identify'\n      , '-ping'\n    ];\n\n    if (val.format) {\n      args.push('-format', val.format);\n    }\n\n    if (val.verbose) {\n      args.push('-verbose');\n    }\n\n    args = args.concat(self.src());\n    return args;\n  }\n\n  /**\n   * Map exif orientation codes to orientation names.\n   */\n\n  var orientations = {\n      '1': 'TopLeft'\n    , '2': 'TopRight'\n    , '3': 'BottomRight'\n    , '4': 'BottomLeft'\n    , '5': 'LeftTop'\n    , '6': 'RightTop'\n    , '7': 'RightBottom'\n    , '8': 'LeftBottom'\n  }\n\n  /**\n   * identify -verbose helpers\n   */\n\n  var helper = gm.identifyHelpers = {};\n\n  helper.Geometry = function Geometry (o, val) {\n    // We only want the size of the first frame.\n    // Each frame is separated by a space.\n    var split = val.split(\" \").shift().split(\"x\");\n    var width = parseInt(split[0], 10);\n    var height = parseInt(split[1], 10);\n    if (o.size && o.size.width && o.size.height) {\n      if (width > o.size.width) o.size.width = width;\n      if (height > o.size.height) o.size.height = height;\n    } else {\n      o.size = {\n        width:  width,\n        height: height\n      }\n    }\n  };\n\n  helper.Format = function Format (o, val) {\n    o.format = val.split(\" \")[0];\n  };\n\n  helper.Depth = function Depth (o, val) {\n    o.depth = parseInt(val, 10);\n  };\n\n  helper.Colors = function Colors (o, val) {\n    o.color = parseInt(val, 10);\n  };\n\n  helper.Orientation = function Orientation (o, val) {\n    if (val in orientations) {\n      o['Profile-EXIF'] || (o['Profile-EXIF'] = {});\n      o['Profile-EXIF'].Orientation = val;\n      o.Orientation = orientations[val];\n    } else {\n      o.Orientation = val || 'Unknown';\n    }\n  };\n}\n\n"]},"metadata":{},"sourceType":"script"}